"""
This file defines a set of agent prompts and a crew class for managing the agents.

The agents are defined as dictionaries with the following keys:
- 'prompt': A PromptTemplate object that represents the prompt for the agent.
- 'parser': An output parser object that parses the output generated by the agent.

The crew class provides methods for creating and managing the agents. It has the following attributes:
- agent_prompts: A list of agent prompts.
- llm: An object representing the LLM (Language Model) used by the agents.
- crew: A dictionary that stores the created agents.

To use this file, create an instance of the crew class and call the build_crew() method to create the agents.

Example usage:
    agent_prompts = ['router', 'rag_chain', 'retrieval_grader']
    llm = LanguageModel()
    my_crew = crew(agent_prompts, llm)
    my_crew.build_crew()
"""

# agent prompts
from langchain.prompts import PromptTemplate
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.output_parsers import StrOutputParser


# Post-processing
def format_docs(docs):
    """
    Format a list of documents into a single string.

    Args:
        docs (list): A list of documents.

    Returns:
        str: A formatted string containing the content of all the documents.
    """
    return "\n\n".join(doc.page_content for doc in docs)

agent_prompts = dict(
    question_router = dict(
        prompt = PromptTemplate(
            template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|> You are an expert at routing a 
            user question to a vectorstore or web search. Use the vectorstore for questions on LLM  agents, 
            prompt engineering, and adversarial attacks. You do not need to be stringent with the keywords 
            in the question related to these topics. Otherwise, use web-search. Give a binary choice 'web_search' 
            or 'vectorstore' based on the question. Return the a JSON with a single key 'datasource' and 
            no premable or explaination. Question to route: {question} <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
            input_variables=["question"],
        ),
        parser = JsonOutputParser(),),

    rag_chain = dict(
        prompt= PromptTemplate(
            template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|> You are an assistant for question-answering tasks. 
            Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. 
            <|eot_id|><|start_header_id|>user<|end_header_id|>
            Question: {question} 
            Context: {context} 
            Answer: <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
            input_variables=["question", "document"],
        ),
        parser = StrOutputParser(),),

    retrieval_grader = dict(
        prompt = PromptTemplate(
            template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|> You are a grader assessing relevance 
            of a retrieved document to a user question. If the document contains keywords related to the user question, 
            grade it as relevant. It does not need to be a stringent test. The goal is to filter out erroneous retrievals. \n
            Give a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question. \n
            Provide the binary score as a JSON with a single key 'score' and no premable or explaination.
            <|eot_id|><|start_header_id|>user<|end_header_id|>
            Here is the retrieved document: \n\n {document} \n\n
            Here is the user question: {question} \n <|eot_id|><|start_header_id|>assistant<|end_header_id|>
            """,
            input_variables=["question", "document"],
        ),
        parser = JsonOutputParser(),),

    hallucination_grader = dict(
        prompt = PromptTemplate(
            template=""" <|begin_of_text|><|start_header_id|>system<|end_header_id|> You are a grader assessing whether 
            an answer is grounded in / supported by a set of facts. Give a binary 'yes' or 'no' score to indicate 
            whether the answer is grounded in / supported by a set of facts. Provide the binary score as a JSON with a 
            single key 'score' and no preamble or explanation. <|eot_id|><|start_header_id|>user<|end_header_id|>
            Here are the facts:
            \n ------- \n
            {documents} 
            \n ------- \n
            Here is the answer: {generation}  <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
            input_variables=["generation", "documents"],
        ),
        parser = JsonOutputParser(),),

    answer_grader = dict(
        prompt = PromptTemplate(
            template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|> You are a grader assessing whether an 
            answer is useful to resolve a question. Give a binary score 'yes' or 'no' to indicate whether the answer is 
            useful to resolve a question. Provide the binary score as a JSON with a single key 'score' and no preamble or explanation.
            <|eot_id|><|start_header_id|>user<|end_header_id|> Here is the answer:
            \n ------- \n
            {generation} 
            \n ------- \n
            Here is the question: {question} <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
            input_variables=["generation", "question"],
        ),
        parser = JsonOutputParser(),),)



    
class crew:
    def __init__(self, agent_prompts, llm):
        """
        Initialize the crew class.

        Args:
            agent_prompts (list): A list of agent prompts.
            llm (object): An object representing the LLM (Language Model) used by the agents.
        """
        self.agent_prompts = agent_prompts
        self.llm = llm
        self.crew = dict()

    def create_agent(self, agent_prompt, parser):
        """
        Create an agent using the given agent prompt and parser.

        Args:
            agent_prompt (PromptTemplate): The agent prompt.
            parser (OutputParser): The output parser.

        Returns:
            Agent: The created agent.
        """
        return agent_prompt | self.llm | parser
    
    def build_crew(self):
        """
        Build the crew by creating the agents based on the agent prompts.
        """
        for agent in self.agent_prompts:
            print(f'Building agent: {agent}')
            self.crew[agent] = self.create_agent(self.agent_prompts[agent]['prompt'], self.agent_prompts[agent]['parser'])
    
if __name__ == "__main__":
    pass

